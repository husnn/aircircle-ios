// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: billing/billing.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum JonoBillingPB_Provider: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unspecified // = 0
  case apple // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .apple
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .apple: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension JonoBillingPB_Provider: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [JonoBillingPB_Provider] = [
    .unspecified,
    .apple,
  ]
}

#endif  // swift(>=4.2)

struct JonoBillingPB_UserIdentifierRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var provider: JonoBillingPB_Provider = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct JonoBillingPB_UserIdentifierResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var uuid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct JonoBillingPB_Usage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var storage: JonoBillingPB_Usage.Storage {
    get {return _storage ?? JonoBillingPB_Usage.Storage()}
    set {_storage = newValue}
  }
  /// Returns true if `storage` has been explicitly set.
  var hasStorage: Bool {return self._storage != nil}
  /// Clears the value of `storage`. Subsequent reads from it will return its default value.
  mutating func clearStorage() {self._storage = nil}

  var recordingDuration30D: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Storage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var available: Int32 = 0

    var used: Int32 = 0

    var free: Int32 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _storage: JonoBillingPB_Usage.Storage? = nil
}

struct JonoBillingPB_SubscriptionPlan {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var name: String = String()

  var groupID: String = String()

  var appleProductID: String = String()

  var duration: JonoBillingPB_SubscriptionPlan.Duration = .unspecified

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Duration: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unspecified // = 0
    case month // = 1
    case year // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .month
      case 2: self = .year
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .month: return 1
      case .year: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension JonoBillingPB_SubscriptionPlan.Duration: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [JonoBillingPB_SubscriptionPlan.Duration] = [
    .unspecified,
    .month,
    .year,
  ]
}

#endif  // swift(>=4.2)

struct JonoBillingPB_UpgradeWall {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var message: String = String()

  var comparisonTable: JonoBillingPB_UpgradeWall.Table {
    get {return _comparisonTable ?? JonoBillingPB_UpgradeWall.Table()}
    set {_comparisonTable = newValue}
  }
  /// Returns true if `comparisonTable` has been explicitly set.
  var hasComparisonTable: Bool {return self._comparisonTable != nil}
  /// Clears the value of `comparisonTable`. Subsequent reads from it will return its default value.
  mutating func clearComparisonTable() {self._comparisonTable = nil}

  var subscriptionGroup: String = String()

  var primaryAction: String = String()

  var dismissAction: String = String()

  var selectionMessage: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Table {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var columnNames: [String] = []

    var rows: [JonoBillingPB_UpgradeWall.Table.Row] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct Field {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var text: String = String()

      var checked: Bool = false

      var comingSoon: Bool = false

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    struct Row {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var name: String = String()

      var fields: [JonoBillingPB_UpgradeWall.Table.Field] = []

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  init() {}

  fileprivate var _comparisonTable: JonoBillingPB_UpgradeWall.Table? = nil
}

struct JonoBillingPB_SubscriptionInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var currentPlan: JonoBillingPB_SubscriptionPlan {
    get {return _storage._currentPlan ?? JonoBillingPB_SubscriptionPlan()}
    set {_uniqueStorage()._currentPlan = newValue}
  }
  /// Returns true if `currentPlan` has been explicitly set.
  var hasCurrentPlan: Bool {return _storage._currentPlan != nil}
  /// Clears the value of `currentPlan`. Subsequent reads from it will return its default value.
  mutating func clearCurrentPlan() {_uniqueStorage()._currentPlan = nil}

  var availablePlans: [JonoBillingPB_SubscriptionPlan] {
    get {return _storage._availablePlans}
    set {_uniqueStorage()._availablePlans = newValue}
  }

  var usage: JonoBillingPB_Usage {
    get {return _storage._usage ?? JonoBillingPB_Usage()}
    set {_uniqueStorage()._usage = newValue}
  }
  /// Returns true if `usage` has been explicitly set.
  var hasUsage: Bool {return _storage._usage != nil}
  /// Clears the value of `usage`. Subsequent reads from it will return its default value.
  mutating func clearUsage() {_uniqueStorage()._usage = nil}

  var appleIdentifier: String {
    get {return _storage._appleIdentifier}
    set {_uniqueStorage()._appleIdentifier = newValue}
  }

  var capabilities: JonoBillingPB_Capabilities {
    get {return _storage._capabilities ?? JonoBillingPB_Capabilities()}
    set {_uniqueStorage()._capabilities = newValue}
  }
  /// Returns true if `capabilities` has been explicitly set.
  var hasCapabilities: Bool {return _storage._capabilities != nil}
  /// Clears the value of `capabilities`. Subsequent reads from it will return its default value.
  mutating func clearCapabilities() {_uniqueStorage()._capabilities = nil}

  var limits: JonoBillingPB_Limits {
    get {return _storage._limits ?? JonoBillingPB_Limits()}
    set {_uniqueStorage()._limits = newValue}
  }
  /// Returns true if `limits` has been explicitly set.
  var hasLimits: Bool {return _storage._limits != nil}
  /// Clears the value of `limits`. Subsequent reads from it will return its default value.
  mutating func clearLimits() {_uniqueStorage()._limits = nil}

  var upgradeWall: JonoBillingPB_UpgradeWall {
    get {return _storage._upgradeWall ?? JonoBillingPB_UpgradeWall()}
    set {_uniqueStorage()._upgradeWall = newValue}
  }
  /// Returns true if `upgradeWall` has been explicitly set.
  var hasUpgradeWall: Bool {return _storage._upgradeWall != nil}
  /// Clears the value of `upgradeWall`. Subsequent reads from it will return its default value.
  mutating func clearUpgradeWall() {_uniqueStorage()._upgradeWall = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct JonoBillingPB_Capabilities {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var importMedia: Bool = false

  var exportMedia: Bool = false

  var rewriteEntry: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct JonoBillingPB_Limits {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var maxRecordingLengthAudio: Int32 = 0

  var maxRecordingLengthVideo: Int32 = 0

  var maxFileSizeAudio: Int64 = 0

  var maxFileSizeVideo: Int64 = 0

  var maxRecordingDurationMonthly: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension JonoBillingPB_Provider: @unchecked Sendable {}
extension JonoBillingPB_UserIdentifierRequest: @unchecked Sendable {}
extension JonoBillingPB_UserIdentifierResponse: @unchecked Sendable {}
extension JonoBillingPB_Usage: @unchecked Sendable {}
extension JonoBillingPB_Usage.Storage: @unchecked Sendable {}
extension JonoBillingPB_SubscriptionPlan: @unchecked Sendable {}
extension JonoBillingPB_SubscriptionPlan.Duration: @unchecked Sendable {}
extension JonoBillingPB_UpgradeWall: @unchecked Sendable {}
extension JonoBillingPB_UpgradeWall.Table: @unchecked Sendable {}
extension JonoBillingPB_UpgradeWall.Table.Field: @unchecked Sendable {}
extension JonoBillingPB_UpgradeWall.Table.Row: @unchecked Sendable {}
extension JonoBillingPB_SubscriptionInfo: @unchecked Sendable {}
extension JonoBillingPB_Capabilities: @unchecked Sendable {}
extension JonoBillingPB_Limits: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "io.jono.billing"

extension JonoBillingPB_Provider: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PROVIDER_UNSPECIFIED"),
    1: .same(proto: "PROVIDER_APPLE"),
  ]
}

extension JonoBillingPB_UserIdentifierRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserIdentifierRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "provider"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.provider) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.provider != .unspecified {
      try visitor.visitSingularEnumField(value: self.provider, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: JonoBillingPB_UserIdentifierRequest, rhs: JonoBillingPB_UserIdentifierRequest) -> Bool {
    if lhs.provider != rhs.provider {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JonoBillingPB_UserIdentifierResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserIdentifierResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "uuid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: JonoBillingPB_UserIdentifierResponse, rhs: JonoBillingPB_UserIdentifierResponse) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JonoBillingPB_Usage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Usage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "storage"),
    2: .standard(proto: "recording_duration_30d"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._storage) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.recordingDuration30D) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._storage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.recordingDuration30D != 0 {
      try visitor.visitSingularInt32Field(value: self.recordingDuration30D, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: JonoBillingPB_Usage, rhs: JonoBillingPB_Usage) -> Bool {
    if lhs._storage != rhs._storage {return false}
    if lhs.recordingDuration30D != rhs.recordingDuration30D {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JonoBillingPB_Usage.Storage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = JonoBillingPB_Usage.protoMessageName + ".Storage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "available"),
    2: .same(proto: "used"),
    3: .same(proto: "free"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.available) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.used) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.free) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.available != 0 {
      try visitor.visitSingularInt32Field(value: self.available, fieldNumber: 1)
    }
    if self.used != 0 {
      try visitor.visitSingularInt32Field(value: self.used, fieldNumber: 2)
    }
    if self.free != 0 {
      try visitor.visitSingularInt32Field(value: self.free, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: JonoBillingPB_Usage.Storage, rhs: JonoBillingPB_Usage.Storage) -> Bool {
    if lhs.available != rhs.available {return false}
    if lhs.used != rhs.used {return false}
    if lhs.free != rhs.free {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JonoBillingPB_SubscriptionPlan: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscriptionPlan"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "name"),
    4: .standard(proto: "group_id"),
    3: .standard(proto: "apple_product_id"),
    5: .same(proto: "duration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.appleProductID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.groupID) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.duration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.appleProductID.isEmpty {
      try visitor.visitSingularStringField(value: self.appleProductID, fieldNumber: 3)
    }
    if !self.groupID.isEmpty {
      try visitor.visitSingularStringField(value: self.groupID, fieldNumber: 4)
    }
    if self.duration != .unspecified {
      try visitor.visitSingularEnumField(value: self.duration, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: JonoBillingPB_SubscriptionPlan, rhs: JonoBillingPB_SubscriptionPlan) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.name != rhs.name {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.appleProductID != rhs.appleProductID {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JonoBillingPB_SubscriptionPlan.Duration: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DURATION_UNSPECIFIED"),
    1: .same(proto: "DURATION_MONTH"),
    2: .same(proto: "DURATION_YEAR"),
  ]
}

extension JonoBillingPB_UpgradeWall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpgradeWall"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "message"),
    3: .standard(proto: "comparison_table"),
    4: .standard(proto: "subscription_group"),
    5: .standard(proto: "primary_action"),
    6: .standard(proto: "dismiss_action"),
    7: .standard(proto: "selection_message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._comparisonTable) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.subscriptionGroup) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.primaryAction) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.dismissAction) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.selectionMessage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try { if let v = self._comparisonTable {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.subscriptionGroup.isEmpty {
      try visitor.visitSingularStringField(value: self.subscriptionGroup, fieldNumber: 4)
    }
    if !self.primaryAction.isEmpty {
      try visitor.visitSingularStringField(value: self.primaryAction, fieldNumber: 5)
    }
    if !self.dismissAction.isEmpty {
      try visitor.visitSingularStringField(value: self.dismissAction, fieldNumber: 6)
    }
    if !self.selectionMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.selectionMessage, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: JonoBillingPB_UpgradeWall, rhs: JonoBillingPB_UpgradeWall) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.message != rhs.message {return false}
    if lhs._comparisonTable != rhs._comparisonTable {return false}
    if lhs.subscriptionGroup != rhs.subscriptionGroup {return false}
    if lhs.primaryAction != rhs.primaryAction {return false}
    if lhs.dismissAction != rhs.dismissAction {return false}
    if lhs.selectionMessage != rhs.selectionMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JonoBillingPB_UpgradeWall.Table: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = JonoBillingPB_UpgradeWall.protoMessageName + ".Table"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "column_names"),
    2: .same(proto: "rows"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.columnNames) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.rows) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.columnNames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.columnNames, fieldNumber: 1)
    }
    if !self.rows.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rows, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: JonoBillingPB_UpgradeWall.Table, rhs: JonoBillingPB_UpgradeWall.Table) -> Bool {
    if lhs.columnNames != rhs.columnNames {return false}
    if lhs.rows != rhs.rows {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JonoBillingPB_UpgradeWall.Table.Field: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = JonoBillingPB_UpgradeWall.Table.protoMessageName + ".Field"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "checked"),
    3: .standard(proto: "coming_soon"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.checked) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.comingSoon) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if self.checked != false {
      try visitor.visitSingularBoolField(value: self.checked, fieldNumber: 2)
    }
    if self.comingSoon != false {
      try visitor.visitSingularBoolField(value: self.comingSoon, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: JonoBillingPB_UpgradeWall.Table.Field, rhs: JonoBillingPB_UpgradeWall.Table.Field) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.checked != rhs.checked {return false}
    if lhs.comingSoon != rhs.comingSoon {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JonoBillingPB_UpgradeWall.Table.Row: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = JonoBillingPB_UpgradeWall.Table.protoMessageName + ".Row"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.fields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.fields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fields, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: JonoBillingPB_UpgradeWall.Table.Row, rhs: JonoBillingPB_UpgradeWall.Table.Row) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.fields != rhs.fields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JonoBillingPB_SubscriptionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscriptionInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "current_plan"),
    2: .standard(proto: "available_plans"),
    3: .same(proto: "usage"),
    4: .standard(proto: "apple_identifier"),
    5: .same(proto: "capabilities"),
    6: .same(proto: "limits"),
    7: .standard(proto: "upgrade_wall"),
  ]

  fileprivate class _StorageClass {
    var _currentPlan: JonoBillingPB_SubscriptionPlan? = nil
    var _availablePlans: [JonoBillingPB_SubscriptionPlan] = []
    var _usage: JonoBillingPB_Usage? = nil
    var _appleIdentifier: String = String()
    var _capabilities: JonoBillingPB_Capabilities? = nil
    var _limits: JonoBillingPB_Limits? = nil
    var _upgradeWall: JonoBillingPB_UpgradeWall? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _currentPlan = source._currentPlan
      _availablePlans = source._availablePlans
      _usage = source._usage
      _appleIdentifier = source._appleIdentifier
      _capabilities = source._capabilities
      _limits = source._limits
      _upgradeWall = source._upgradeWall
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._currentPlan) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._availablePlans) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._usage) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._appleIdentifier) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._capabilities) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._limits) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._upgradeWall) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._currentPlan {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      if !_storage._availablePlans.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._availablePlans, fieldNumber: 2)
      }
      try { if let v = _storage._usage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      if !_storage._appleIdentifier.isEmpty {
        try visitor.visitSingularStringField(value: _storage._appleIdentifier, fieldNumber: 4)
      }
      try { if let v = _storage._capabilities {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._limits {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._upgradeWall {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: JonoBillingPB_SubscriptionInfo, rhs: JonoBillingPB_SubscriptionInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._currentPlan != rhs_storage._currentPlan {return false}
        if _storage._availablePlans != rhs_storage._availablePlans {return false}
        if _storage._usage != rhs_storage._usage {return false}
        if _storage._appleIdentifier != rhs_storage._appleIdentifier {return false}
        if _storage._capabilities != rhs_storage._capabilities {return false}
        if _storage._limits != rhs_storage._limits {return false}
        if _storage._upgradeWall != rhs_storage._upgradeWall {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JonoBillingPB_Capabilities: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Capabilities"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "import_media"),
    2: .standard(proto: "export_media"),
    3: .standard(proto: "rewrite_entry"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.importMedia) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.exportMedia) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.rewriteEntry) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.importMedia != false {
      try visitor.visitSingularBoolField(value: self.importMedia, fieldNumber: 1)
    }
    if self.exportMedia != false {
      try visitor.visitSingularBoolField(value: self.exportMedia, fieldNumber: 2)
    }
    if self.rewriteEntry != false {
      try visitor.visitSingularBoolField(value: self.rewriteEntry, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: JonoBillingPB_Capabilities, rhs: JonoBillingPB_Capabilities) -> Bool {
    if lhs.importMedia != rhs.importMedia {return false}
    if lhs.exportMedia != rhs.exportMedia {return false}
    if lhs.rewriteEntry != rhs.rewriteEntry {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension JonoBillingPB_Limits: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Limits"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_recording_length_audio"),
    2: .standard(proto: "max_recording_length_video"),
    4: .standard(proto: "max_file_size_audio"),
    3: .standard(proto: "max_file_size_video"),
    5: .standard(proto: "max_recording_duration_monthly"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.maxRecordingLengthAudio) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.maxRecordingLengthVideo) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.maxFileSizeVideo) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.maxFileSizeAudio) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.maxRecordingDurationMonthly) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxRecordingLengthAudio != 0 {
      try visitor.visitSingularInt32Field(value: self.maxRecordingLengthAudio, fieldNumber: 1)
    }
    if self.maxRecordingLengthVideo != 0 {
      try visitor.visitSingularInt32Field(value: self.maxRecordingLengthVideo, fieldNumber: 2)
    }
    if self.maxFileSizeVideo != 0 {
      try visitor.visitSingularInt64Field(value: self.maxFileSizeVideo, fieldNumber: 3)
    }
    if self.maxFileSizeAudio != 0 {
      try visitor.visitSingularInt64Field(value: self.maxFileSizeAudio, fieldNumber: 4)
    }
    if self.maxRecordingDurationMonthly != 0 {
      try visitor.visitSingularInt32Field(value: self.maxRecordingDurationMonthly, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: JonoBillingPB_Limits, rhs: JonoBillingPB_Limits) -> Bool {
    if lhs.maxRecordingLengthAudio != rhs.maxRecordingLengthAudio {return false}
    if lhs.maxRecordingLengthVideo != rhs.maxRecordingLengthVideo {return false}
    if lhs.maxFileSizeAudio != rhs.maxFileSizeAudio {return false}
    if lhs.maxFileSizeVideo != rhs.maxFileSizeVideo {return false}
    if lhs.maxRecordingDurationMonthly != rhs.maxRecordingDurationMonthly {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
